<!DOCTYPE html>

<html lang="en" data-content_root="../../../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>xrf_explorer.server.spectra &#8212; XRF-Explorer 2.0 0.2.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=12dfc556" />
    <script src="../../../_static/documentation_options.js?v=938c9ccc"></script>
    <script src="../../../_static/doctools.js?v=9a2dae69"></script>
    <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <h1>Source code for xrf_explorer.server.spectra</h1><div class="highlight"><pre>
<span></span><span class="c1">#This module contains all functions related to the spectral chart</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> 
<span class="kn">import</span> <span class="nn">xraydb</span> 
<span class="kn">import</span> <span class="nn">logging</span>

<span class="kn">from</span> <span class="nn">xrf_explorer.server.file_system.file_access</span> <span class="kn">import</span> <span class="n">get_raw_rpl_paths</span><span class="p">,</span> <span class="n">parse_rpl</span>
<span class="n">LOG</span><span class="p">:</span> <span class="n">logging</span><span class="o">.</span><span class="n">Logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<div class="viewcode-block" id="get_raw_data">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.get_raw_data">[docs]</a>
<span class="k">def</span> <span class="nf">get_raw_data</span><span class="p">(</span><span class="n">data_source</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Parse the raw data cube of a data source as a 3-dimensional numpy array</span>
<span class="sd">    </span>
<span class="sd">    :param data_source: the path to the .raw file</span>
<span class="sd">    :</span>
<span class="sd">    :return: 3-dimensional array containing the raw data in format {x, y, channel}</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#get paths to files</span>
    <span class="n">path_to_raw</span><span class="p">,</span> <span class="n">path_to_rpl</span> <span class="o">=</span> <span class="n">get_raw_rpl_paths</span><span class="p">(</span><span class="n">data_source</span><span class="p">)</span>
    
    <span class="c1">#get dimensions from rpl file</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">parse_rpl</span><span class="p">(</span><span class="n">path_to_rpl</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">info</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

    <span class="n">width</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;width&#39;</span><span class="p">])</span>
    <span class="n">height</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;height&#39;</span><span class="p">])</span>
    <span class="n">channels</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;depth&#39;</span><span class="p">])</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1">#load raw file and parse it as 3d array with correct dimensions</span>
        <span class="n">datacube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">memmap</span><span class="p">(</span><span class="n">path_to_raw</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint16</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">err</span><span class="p">:</span>
        <span class="n">LOG</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;error while loading raw file: {</span><span class="si">%s</span><span class="s2">}&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[]</span>
    <span class="n">datacube</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">datacube</span><span class="p">,</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">channels</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">datacube</span></div>


<div class="viewcode-block" id="get_average_global">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.get_average_global">[docs]</a>
<span class="k">def</span> <span class="nf">get_average_global</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">low</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the average of the raw data for each bin of channels in range [low, high] on the whole painting</span>
<span class="sd">    Precondition: 0 &lt;= low &lt; high &lt;= 4096, 0 &lt; bin_sinze &lt;= 4096</span>
<span class="sd">    </span>
<span class="sd">    :param data: datacube containing the raw data</span>
<span class="sd">    :param low: lower channel boundary</span>
<span class="sd">    :param high: higher channel boundary</span>
<span class="sd">    :param bin_size: size of each bin</span>
<span class="sd">    :return: list with the average raw data for each bin in the range</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">average_values</span> <span class="o">=</span> <span class="p">[]</span>
    
    <span class="c1">#compute average per channel per bin size and add to dictionary</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">):</span>
        <span class="n">mean</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">bin_size</span><span class="p">]</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
        <span class="n">average_values</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">mean</span><span class="p">})</span>
    
    <span class="k">return</span> <span class="n">average_values</span></div>


<div class="viewcode-block" id="get_average_selection">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.get_average_selection">[docs]</a>
<span class="k">def</span> <span class="nf">get_average_selection</span><span class="p">(</span><span class="n">data</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">pixels</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">low</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Computes the average of the raw data for each bin of channels in range [low, high] on the selected pixels</span>
<span class="sd">    Precondition: 0 &lt;= low &lt; high &lt;= 4096, 0 &lt; bin_sinze &lt;= 4096</span>
<span class="sd">    Precondition: forall pixel in pixels, 0 &lt;= pixel[0] &lt; width, 0 &lt;= pixel[1] &lt; height</span>
<span class="sd">    </span>
<span class="sd">    :param data: datacube containing the raw data</span>
<span class="sd">    :param pixels: list of selected pixels</span>
<span class="sd">    :param low: lower channel boundary</span>
<span class="sd">    :param high: higher channel boundary</span>
<span class="sd">    :param bin_size: size of each bin</span>
<span class="sd">    :return: list with the average raw data for each bin in the range</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">if</span> <span class="n">pixels</span><span class="p">:</span>
        <span class="c1">#initialize average array of length the number of channels</span>
        <span class="nb">sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span>

        <span class="c1">#add the required channels of all pixels</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">pixels</span><span class="p">)):</span>
            <span class="n">pixel_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">pixels</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">low</span><span class="p">:</span><span class="n">high</span><span class="p">]</span>
            <span class="nb">sum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="n">pixel_data</span><span class="p">)</span>
        
        <span class="c1">#average</span>
        <span class="n">avg</span> <span class="o">=</span> <span class="nb">sum</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">pixels</span><span class="p">)</span>
        
        <span class="n">result</span> <span class="o">=</span> <span class="p">[]</span>
        
        <span class="c1">#average per bin</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">low</span><span class="p">,</span> <span class="n">high</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">):</span>
            <span class="n">mean</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">avg</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="n">low</span><span class="p">:</span><span class="n">i</span><span class="o">-</span><span class="n">low</span><span class="o">+</span><span class="n">bin_size</span><span class="p">])</span>
            <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">mean</span><span class="p">}</span>
            <span class="n">result</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>   

        <span class="k">return</span> <span class="n">result</span>
    <span class="k">else</span> <span class="p">:</span>
        <span class="k">return</span> <span class="p">[]</span></div>

    
<div class="viewcode-block" id="get_theoretical_data">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.get_theoretical_data">[docs]</a>
<span class="k">def</span> <span class="nf">get_theoretical_data</span><span class="p">(</span><span class="n">element</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">excitation_energy_keV</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">low</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">bin_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get the theoretical spectrum and peaks of an element</span>
<span class="sd">        Precondition: 0 &lt;= low &lt; high &lt;= 4096, 0 &lt; bin_sinze &lt;= 4096</span>

<span class="sd">        :param element: symbol of the element</span>
<span class="sd">        :excitation_energy_keV: excitation energy</span>
<span class="sd">        :param low: lower channel boundary</span>
<span class="sd">        :param high: higher channel boundary</span>
<span class="sd">        :param bin_size: size of each bin</span>
<span class="sd">        :return: list with first element being a list of dictionaries representing the spectra points, secodn being a list of dictionaries representing the peaks</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="c1">#remove last character to get periodic table symbol</span>
    <span class="n">element</span> <span class="o">=</span> <span class="n">element</span><span class="p">[:</span><span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">element</span> <span class="o">==</span> <span class="s1">&#39;yAl&#39;</span><span class="p">:</span>
        <span class="n">element</span> <span class="o">=</span> <span class="s1">&#39;Al&#39;</span>
    
    <span class="c1">#get spectrum and peaks</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">get_element_spectrum</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">excitation_energy_keV</span><span class="p">)</span>
    
    <span class="c1">#get_element_spectrum returns normalized data, rescale to [0, 255]</span>
    <span class="n">y_scale</span> <span class="o">=</span> <span class="mi">255</span>
    
    <span class="c1">#get_element_spectrum returns 10000 points instead of &#39;high-low&#39; points, so rescale bin_size</span>
    <span class="n">bin_size</span> <span class="o">=</span> <span class="nb">round</span><span class="p">(</span><span class="n">bin_size</span><span class="o">/</span><span class="p">((</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
    
    <span class="n">response</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">spectrum</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">bin_size</span><span class="p">):</span>
        <span class="c1">#take average of the y-values in the bin</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">:</span><span class="n">i</span><span class="o">+</span><span class="n">bin_size</span><span class="p">])</span>
        
        <span class="c1">#rescale index to domain [low, high] and the mean to range [0, 255]</span>
        <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="o">*</span><span class="p">((</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span><span class="o">+</span><span class="n">low</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">value</span><span class="o">*</span><span class="n">y_scale</span><span class="p">}</span>
        <span class="n">spectrum</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">spectrum</span><span class="p">)</span>
    
    <span class="c1">#get_element_spectrum returns data in domain [0, 40], rescale to [low, high]</span>
    <span class="n">x_scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">high</span><span class="o">-</span><span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="nb">abs</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">-</span><span class="n">data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">())</span>
    
    <span class="n">peaks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
        <span class="c1">#take only the peaks within the domain [high, low]</span>
        <span class="k">if</span><span class="p">(</span><span class="n">low</span><span class="o">&lt;=</span><span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x_scale</span> <span class="o">+</span> <span class="n">low</span> <span class="ow">and</span> <span class="n">high</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x_scale</span> <span class="o">+</span> <span class="n">low</span><span class="p">):</span>
            <span class="c1">#scale x and y values</span>
            <span class="nb">dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">x_scale</span> <span class="o">+</span> <span class="n">low</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">data</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">i</span><span class="p">]</span><span class="o">*</span><span class="n">y_scale</span><span class="p">}</span>
            <span class="n">peaks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">response</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peaks</span><span class="p">)</span>
    
    <span class="k">return</span> <span class="n">response</span></div>



<span class="c1">#functions to compute theoratical elemental spectrum</span>
<span class="c1">#From xrf4u: https://github.com/fligt/maxrf4u/blob/main/maxrf4u/xphysics.py</span>
<span class="c1">#Author: Frank Ligterink</span>
<div class="viewcode-block" id="ElementLines">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.ElementLines">[docs]</a>
<span class="k">class</span> <span class="nc">ElementLines</span><span class="p">():</span> 
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Computes fluorescence emission line energies and intensities for `element`.</span>
<span class="sd">    </span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">,</span> <span class="n">excitation_energy_keV</span><span class="p">):</span> 

        <span class="n">excitation_energy</span> <span class="o">=</span> <span class="mi">1000</span> <span class="o">*</span> <span class="n">excitation_energy_keV</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">xraydb</span><span class="o">.</span><span class="n">xray_lines</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">excitation_energy</span><span class="o">=</span><span class="n">excitation_energy</span><span class="p">)</span> 

        <span class="n">peak_names</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_labels</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">peak_energies</span> <span class="o">=</span> <span class="p">[]</span> 
        <span class="n">peak_intensities</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="o">.</span><span class="n">items</span><span class="p">():</span> 

            <span class="n">peak_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

            <span class="c1"># intensities (a.k.a. transition probablities) sum up to unity within each level </span>
            <span class="n">energy</span><span class="p">,</span> <span class="n">intensity</span><span class="p">,</span> <span class="n">initial_level</span><span class="p">,</span> <span class="n">final_level</span> <span class="o">=</span> <span class="n">line</span>  
            <span class="n">peak_energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">energy</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">element</span><span class="si">}</span><span class="s1">_</span><span class="si">{</span><span class="n">initial_level</span><span class="si">}{</span><span class="n">final_level</span><span class="si">}</span><span class="s1">&#39;</span> 
            <span class="n">peak_labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="c1"># get corresponding edge properties </span>
            <span class="n">edge</span> <span class="o">=</span> <span class="n">initial_level</span> <span class="c1"># IUPAC notation!  e.g. &#39;L1&#39;, not &#39;La&#39;</span>
            <span class="n">edge_energy</span><span class="p">,</span> <span class="n">fluo_yield</span><span class="p">,</span> <span class="n">jump_ratio</span> <span class="o">=</span> <span class="n">xraydb</span><span class="o">.</span><span class="n">xray_edge</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">edge</span><span class="p">)</span> 
            <span class="n">jump_coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">jump_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">jump_ratio</span> <span class="c1"># see Volker </span>
            <span class="c1">#print(f&#39;{name}: {energy}; jump_coeff: {jump_coeff:.03f}; fluo_yield: {fluo_yield}&#39;)</span>

            <span class="c1"># multiplying edge jump coefficient, intensity and fluorescence yield... </span>
            <span class="n">peak_intensity</span> <span class="o">=</span> <span class="n">jump_coeff</span> <span class="o">*</span> <span class="n">intensity</span> <span class="o">*</span> <span class="n">fluo_yield</span> 
            <span class="n">peak_intensities</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">peak_intensity</span><span class="p">)</span> 
        
        <span class="c1"># determine sorting according to peak_intensities... </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_intensities</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peak_intensities</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">peak_intensities</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> 

        <span class="c1"># sort </span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_intensities</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">peak_intensities</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_energies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peak_energies</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span> <span class="o">/</span> <span class="mi">1000</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_names</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peak_names</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">peak_labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">peak_labels</span><span class="p">)[</span><span class="n">indices</span><span class="p">]</span></div>


        
<div class="viewcode-block" id="get_element_spectrum">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.get_element_spectrum">[docs]</a>
<span class="k">def</span> <span class="nf">get_element_spectrum</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">excitation_energy_keV</span><span class="p">,</span> <span class="n">normalize</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">x_keVs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Compute simple excitation spectrum (no matrix effects) and peaks</span>
<span class="sd">    </span>
<span class="sd">    :param element: symbol of the element</span>
<span class="sd">    :param excitation_energy_keV: excitation energy</span>
<span class="sd">    :param normalize: boolean representing wether to normalize y values</span>
<span class="sd">    :param x_keVs: pre-determined x values</span>
<span class="sd">    :param std: standard deviation of gaussian filter</span>
<span class="sd">    :return: x values of the spectrum, y values of the spectrum, peak energies, peak intensities</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="n">el</span> <span class="o">=</span> <span class="n">ElementLines</span><span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">excitation_energy_keV</span><span class="p">)</span>  
    <span class="n">pe</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">peak_energies</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">peak_intensities</span>
    
    <span class="n">x</span><span class="p">,</span> <span class="n">y_spectrum</span> <span class="o">=</span> <span class="n">gaussian_convolve</span><span class="p">(</span><span class="n">pe</span><span class="p">,</span> <span class="n">pi</span><span class="p">,</span> <span class="n">x_keVs</span><span class="o">=</span><span class="n">x_keVs</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="n">std</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span> 
        <span class="n">y_spectrum</span> <span class="o">=</span> <span class="n">y_spectrum</span> <span class="o">/</span> <span class="n">y_spectrum</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        
    <span class="k">if</span> <span class="n">x_keVs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
    
        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y_spectrum</span><span class="p">,</span> <span class="n">pe</span><span class="p">,</span> <span class="n">pi</span>
    
    <span class="k">else</span><span class="p">:</span> 
        <span class="k">return</span> <span class="n">y_spectrum</span></div>


    
<div class="viewcode-block" id="get_element_spectra">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.get_element_spectra">[docs]</a>
<span class="k">def</span> <span class="nf">get_element_spectra</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="n">x_keVs</span><span class="p">,</span> <span class="n">excitation_energy_keV</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Compute theoretical emission spectrum for multiple elements. </span>
<span class="sd">    Sorts elements according to largest (alpha) peak. Based on xraydb. </span>
<span class="sd">    </span>
<span class="sd">    :param element: symbols of the elements</span>
<span class="sd">    :param x_keVs: pre-determined x values</span>
<span class="sd">    :param excitation_energy_keV: excitation energy</span>
<span class="sd">    :returns: elements, element_spectra</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="n">n_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">x_keVs</span><span class="p">)</span>
    <span class="n">n_elements</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>

    <span class="n">element_spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">n_elements</span><span class="p">,</span> <span class="n">n_channels</span><span class="p">])</span> 

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elem</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span> 
        <span class="n">element_spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_element_spectrum</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">excitation_energy_keV</span><span class="p">,</span> <span class="n">x_keVs</span><span class="o">=</span><span class="n">x_keVs</span><span class="p">)</span>

        <span class="c1"># normalize</span>
        <span class="n">element_spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">element_spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">element_spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>


    <span class="c1"># sort according to energy of largest (=alpha) peak</span>
    <span class="n">alpha_idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">element_spectra</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">alpha_order</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">alpha_idxs</span><span class="p">)</span> 

    <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">elements</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">alpha_order</span><span class="p">]</span>
    <span class="n">element_spectra</span> <span class="o">=</span> <span class="n">element_spectra</span><span class="p">[</span><span class="n">alpha_order</span><span class="p">]</span>
    
    <span class="k">return</span> <span class="n">elements</span><span class="p">,</span> <span class="n">element_spectra</span> </div>


<div class="viewcode-block" id="gaussian_convolve">
<a class="viewcode-back" href="../../../xrf_explorer.server.html#xrf_explorer.server.spectra.gaussian_convolve">[docs]</a>
<span class="k">def</span> <span class="nf">gaussian_convolve</span><span class="p">(</span><span class="n">peak_energies</span><span class="p">,</span> <span class="n">peak_intensities</span><span class="p">,</span> <span class="n">x_keVs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span> 
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Convolves line spectrum defined by `peak_energies` and `peak_intensities` </span>
<span class="sd">    with a Gaussian peak shape. </span>
<span class="sd">    </span>
<span class="sd">    :param peak_energies: peak energies of the element</span>
<span class="sd">    :param peak_intensities: peak intensities of the element</span>
<span class="sd">    :param x_keVs: pre-determined x values</span>
<span class="sd">    :param std: standard deviation of gaussian filter</span>
<span class="sd">    &#39;&#39;&#39;</span>
    
    <span class="k">if</span> <span class="n">x_keVs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span> 
        <span class="n">x_keVs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">10000</span><span class="p">)</span>

    <span class="n">y_spectrum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">x_keVs</span><span class="p">)</span> 

    <span class="k">for</span> <span class="n">peak_energy</span><span class="p">,</span> <span class="n">peak_intensity</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">peak_energies</span><span class="p">,</span> <span class="n">peak_intensities</span><span class="p">):</span> 

        <span class="n">y_spectrum</span> <span class="o">+=</span> <span class="n">peak_intensity</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="mi">1</span> <span class="o">/</span> <span class="n">std</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">x_keVs</span> <span class="o">-</span> <span class="n">peak_energy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        
    <span class="k">return</span> <span class="n">x_keVs</span><span class="p">,</span> <span class="n">y_spectrum</span> </div>

</pre></div>

          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">XRF-Explorer 2.0</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Python Modules:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">xrf-explorer</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Vue Components:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../components.html">components</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  <li><a href="../../index.html">Module code</a><ul>
  <li><a href="../../xrf_explorer.html">xrf_explorer</a><ul>
  </ul></li>
  </ul></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, Pablo Benayas Penas, Jan Bulthuis, Dirk Burgers, Ivan Ivanov, Lotte Lakeman, Massimo Leal Martel, Sonia Maxim, Diego Rivera Garrido, Ruben Savelkouls, Iliyan Teofilov, Adrien Verri√©le.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.3.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
    </div>

    

    
  </body>
</html>